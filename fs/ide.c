/*
 * Minimal PIO-based (non-interrupt-driven) IDE driver code.
 * For information about what all this IDE/ATA magic means,
 * see the materials available on the class references page.
 */

#include "fs.h"
#include <inc/x86.h>


/*-----------------------------STATUS REGISTERS-------------------------------------*/
//Indicates the drive is preparing to send/receive data (wait for it to clear). In case of 'hang' (it never clears), do a software reset.
#define IDE_BSY  0x80
//Bit is clear when drive is spun down, or after an error. Set otherwise.
#define IDE_DRDY 0x40
//	Drive Fault Error (does not set ERR).
#define IDE_DF   0x20
//Indicates an error occurred. Send a new command to clear it (or nuke it with a Software Reset).
#define IDE_ERR  0x01
/*----------------------------------------------------------------------------------*/


/*-----------------------------REGISTERS-------------------------------------*/
/*
    ports from "I/0 base"
    port 0  R/W - Data Register                    -    Read/Write PIO data bytes   
    port 1	R	- Error Register                   -	Used to retrieve any error generated by the last ATA command executed.	8-bit / 16-bit
    port 1	W	- Features Register                -	Used to control command specific interface features.	8-bit / 16-bit
    port 2	R/W	- Sector Count Register            -	Number of sectors to read/write (0 is a special value).	8-bit / 16-bit
    port 3	R/W	- Sector Number Register (LBAlo)   - 	This is CHS / LBA28 / LBA48 specific.	8-bit / 16-bit
    port 4	R/W	- Cylinder Low Register / (LBAmid) -	Partial Disk Sector address.	8-bit / 16-bit
    port 5	R/W	- Cylinder High Register / (LBAhi) -	Partial Disk Sector address.	8-bit / 16-bit
    port 6	R/W	- Drive / Head Register            -	Used to select a drive and/or head. Supports extra address/flag bits.	8-bit / 8-bit
    port 7	R	- Status Register	               -    Used to read the current status.	8-bit / 8-bit
    port 7	W	- Command Register                 -	Used to send ATA commands to the device. 
*/
/*--------------------------------------------------------------------------*/
static int diskno = 1;

static int
ide_wait_ready(bool check_error) {
    int r;

    while (((r = inb(0x1F7)) & (IDE_BSY | IDE_DRDY)) != IDE_DRDY) /* nothing */
        ;

    if (check_error && (r & (IDE_DF | IDE_ERR)) != 0) return -1;
    return 0;
}

bool
ide_probe_disk1(void) {
    int x;

    /* Wait for Device 0 to be ready */
    ide_wait_ready(0);

    /* Switch to Device 1 */
    outb(0x1F6, 0xE0 | (1 << 4));

    /* Check for Device 1 to be ready for a while */
    for (x = 0; x < 1000 && (inb(0x1F7) & (IDE_BSY | IDE_DF | IDE_ERR)) != 0; x++) /* nothing */
        ;

    /* Switch back to Device 0 */
    outb(0x1F6, 0xE0 | (0 << 4));

    cprintf("Device 1 presence: %d\n", (x < 1000));
    return (x < 1000);
}

void
ide_set_disk(int d) {
    if (d != 0 && d != 1)
        panic("bad disk number");
    diskno = d;
}

int
ide_read(uint32_t secno, void *dst, size_t nsecs) {
    int r;

    assert(nsecs <= 256);

    ide_wait_ready(0);

    outb(0x1F2, nsecs);
    outb(0x1F3, secno & 0xFF);
    outb(0x1F4, (secno >> 8) & 0xFF);
    outb(0x1F5, (secno >> 16) & 0xFF);
    outb(0x1F6, 0xE0 | ((diskno & 1) << 4) | ((secno >> 24) & 0x0F));
    outb(0x1F7, 0x20); /* CMD 0x20 means read sector */

    for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
        if ((r = ide_wait_ready(1)) < 0) return r;
        insl(0x1F0, dst, SECTSIZE / 4);
    }

    return 0;
}

int
ide_write(uint32_t secno, const void *src, size_t nsecs) {
    int r;

    assert(nsecs <= 256);

    ide_wait_ready(0);

    outb(0x1F2, nsecs);
    outb(0x1F3, secno & 0xFF);
    outb(0x1F4, (secno >> 8) & 0xFF);
    outb(0x1F5, (secno >> 16) & 0xFF);
    outb(0x1F6, 0xE0 | ((diskno & 1) << 4) | ((secno >> 24) & 0x0F));
    outb(0x1F7, 0x30); /* CMD 0x30 means write sector */

    for (; nsecs > 0; nsecs--, src += SECTSIZE) {
        if ((r = ide_wait_ready(1)) < 0) return r;
        outsl(0x1F0, src, SECTSIZE / 4);
    }

    return 0;
}
